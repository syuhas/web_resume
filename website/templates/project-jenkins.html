
{% extends "base.html" %} 

{% block title %}Project - Jenkins Dynamic Pipeline{% endblock %}
{% block head %}

{{ super() }}

<link rel="stylesheet" href="{{ url_for('static', filename='css/project-users.css') }}">

{% endblock %}
{% block content %}



<div class="container mx-auto mt-4" style="max-width: 100%;">
    
    
<!-- intro pic -->
    <div class="row justify-content-center" id="intro">
        <div class="col-md-8" id="intro-decorator">

            <div class="row justify-content-center">
                <div class="col-md-10">
                    <h1 class="text-center mt-4 justify-items-center" id="heading"><hr>Jenkins Pipeline with Dynamic Cloud Provisioning<hr></h1>
                    <h6 class="text-center" id="subheading">Fully automated build pipeline with dynamically provisioned cloud node to push containterized applications to AWS.</h6>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-md-10" id="intr-img">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/jenkinsDocker.png') }}" alt="">
                </div>
            </div>
        </div>
    </div>

<!-- overview -->
    <div class="row justify-content-center mt-4 my-4" id="overview">
        <div class="col-md-8" id="decorator" style="padding-bottom: 3vh;">

            <div class="row justify-content-center">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Overview</h4>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-11">
                    <p>For this project I wanted to delve into the popular CI/CD pipeline tool <span>Jenkins</span> and explore the benefits of using cloud computing to <span>save on cost and resource 
                        usage</span>. I created a simple <span>Python Flask</span> skeleton application to be containerized on <span>Docker</span> and my goal was to have Jenkins fully automate the process from the initial git 
                        push from my local machine all the way up to building and pushing the image to <span>AWS ECR</span> to be run as a task on <span>ECS</span>. To fully take advantage of the agility and speed of cloud 
                        computing as well as the ‘pay as you go’ philosophy behind cost savings, I wanted to only have a build server provisioned when I needed it. This way I am not running 
                        unnecessary idle servers, I can scale to multiple build nodes as needed in minutes and can benefit on the cost savings of only using the resources I need, when I need 
                        them.
                        <br><br>
                        Much of the challenge of a project like this is configuration of <span>authorization and integration between services</span>. This task is made much easier through the use of Jenkins plugins
                         that allow for easier storing and usage of credentials. In this project review I will go over all of the configuration needed to automate the pipeline and highlight all 
                         of the features I took advantage of to achieve the end result.
                        </p>
                </div>
            </div>
            <div id="cont"></div>
        </div>
    </div>
<!-- links -->
    <div class="row justify-content-center mt-4 my-4" id="links">
        <div class="col-md-8" id="decorator">

            <div class="row justify-content-center">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Page Contents</h4>
                </div>
            </div>
            
            <div class="mx-5 row justify-content-center">
                <div class="col-6">
                    <p><a href="#master">Jenkins Master and Plugin Configuration</a></p>
                    <p><a href="#git">GitHub Integration</a></p>
                    <p><a href="#py">Python Application Summary</a></p>
                    <p><a href="#aws">AWS Integration</a></p>
                    <p><a href="#ecr">ECR Permissions</a></p>
                    <p><a href="#dynamic">Configuring Dynamic Cloud Node</a></p>
                </div>
                <div class="col-6 justify-content-center" style="padding-bottom: 2em;">
                    <p><a href="#jdfile">Jenkinsfile/Dockerfile</a></p>
                    <p><a href="#pipeconfig">Pipeline Configuration</a></p>
                    <p><a href="#run">Running the Pipeline</a></p>
                    <p><a href="#summary">Summary</a></p>
                    <p><a class="greenlink" href="https://github.com/syuhas/jenkinsTest" target="_blank" rel="noopener noreferrer">Github Repo</a></p>
                </div>
            </div>
            
        </div>
    </div>
<!-- master server -->
    <div class="row justify-content-center mt-4 my-4" id="master">
        <div class="col-md-8" id="decorator">

            <div class="row">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Jenkins Master Node and Plugin Configuration</h4>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-md-10" style="padding-bottom: 5vh;">
                     <p>To run and configure all of the build jobs, I set up a <span>master Jenkins server</span> on an AWS <span>EC2 instance</span>. The server is routed through my domain at digitalsteve.net and behind a load
                        balancer for <span>HTTPS</span> encryption and an <span>Elastic IP address</span>.
                     </p>
                </div>
            </div>
            <!-- picture section 1 -->
            <div class="row justify-content-center">
                <div class="col-md-10">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/master1.png') }}" alt="">
               </div>
                <div class="col-md-4 m-auto" style="padding: 4em;">
                     <p>The main plugins used for this project are: <br><br> <span>“Amazon EC2”</span>, <br> <span>“Cloudbees AWS Credentials”</span>, <br> <span>“Credentials”</span>, <br> <span>“Github”</span>, <br> <span>“Pipeline”</span>, <br> <span>“SSH Credentials”</span></p>
                </div>
            </div>
            <!-- picture section 2 -->
            <div class="row justify-content-center mt-3" style="padding-bottom: 2em;">
                <div class="col-md-6 m-auto">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/master2.png') }}" alt="">
                </div>
                <div class="col-md-6 mt-3">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/master3.png') }}" alt="">
               </div>
            </div>
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
            
        </div>
    </div>
<!-- git -->
    <div class="row justify-content-center mt-4 my-4" id="git">
        <div class="col-md-8" id="decorator">
            <!-- intro section -->
            <div class="row">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">GitHub Integration</h4>
                </div>
            </div>
            
            <!-- picture section 1 -->
            <div class="row justify-content-center">
                <div class="col-md-6 m-auto" style="padding: 4em;">
                     <p>The first step of GitHub integration requires enabling a <span>PAT(Personal Access Token)</span> to be used on the Jenkins master server to allow Jenkins to use the <span>GitHub API</span>.
                        This will allow Jenkins to clone my repository on my build node for the <span>SCM checkout phase</span>.</p>
                </div>
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/git1.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/git2.png') }}" alt="">
               </div>
            </div>
            <!-- picture section 2 -->
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/git3.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/git4.png') }}" alt="">
               </div>
               <div class="col-md-6 pt-5 m-auto">
                    <p>Next, I set up a <span>Webhook</span> on GitHub that allows push notifications to flow downstream to Jenkins and <span>trigger a pipeline</span> job after my code updates are committed.
                        Later, I will go over using the credentials when configuring a job and enabling the Webhook to push code from GitHub to Jenkins to trigger the pipeline to run.
                        <br><br>
                        For the <span>payload url</span> I simply need to append <span>/github-webhook/</span> to the end of my master server url to allow the Webhook to push code to Jenkins with the <span>GitSCM polling trigger</span> enabled.
                        <br><br>
                        I also generated an <span>API token</span> for my username to secure the webhook to my account. This is then entered as the Webhook secret.
                    </p>
                </div>
            </div>
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
        </div>
    </div>
<!-- python and pipeline -->
    <div class="row justify-content-center mt-4 my-4" id="py">
        <div class="col-md-8" id="decorator">
            <!-- intro section -->
            <div class="row">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Python Application Summary</h4>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-md-10" style="padding-bottom: 2vh;">
                    <p>I chose to use a simple <span>Python Flask skeleton application</span> to run through the pipeline to test out the functionality for demo purposes. The application
                    will be run on a <span>Docker</span> container after building the image on the Jenkins build server and <span>pushing the image to ECR to run as an ECS task</span>.</p>
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/py1.png') }}" alt="">
                </div>
                <div class="col-md-6 mt-2">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/py2.png') }}" alt="">
               </div>
            </div>
            <div class="row justify-content-center mt-2" style="padding-bottom: 2em;">
                <div class="col-md-6 m-auto">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/py3.png') }}" alt="">
                </div>
                <div class="col-md-6 mt-2">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/py4.png') }}" alt="">
               </div>
            </div>
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
        </div>
    </div>
<!-- aws -->
    <div class="row justify-content-center mt-4 my-4" id="aws">
        <div class="col-md-8" id="decorator">
            <!-- intro section -->
            <div class="row">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">AWS Integration</h4>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-md-6" style="padding: 3em;">
                    <p>Correct AWS integration is the most important portion of the setup for this pipeline. Jenkins needs to be able to interact with AWS via the <span>AWS CLI to provision servers</span>, <span>SSH into the
                        dynamically provisioned cloud server</span> to manipulate the EC2 instance OS, and ultimately <span>push the Docker image to ECR</span>. This is also the stage where the 'least privilege' principle is important 
                        to keep in mind as sensitive credentials will be passed through the server. Here I am using the <span>Cloudbees EC2 plugin</span> to securely input public/Secret access keys and <span>SSH key pair</span> credentials.
                        For this project, I am granting more privileges than necessary. In production, a privilege analysis should be done to determine the least amount of authorization to run the pipeline.
                        <br><br><br>
                        First, I generated <span>public and private access keys</span> for my user and entered the credentials via the Cloudbees plugin.
                        <br><br><br>
                        I also attached an <span>AWS role</span> to the credentials which will be used for AWS services provisioning and pushing images to ECR which is described below.
                    </p>
                </div>
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/aws1.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/aws2.png') }}" alt="">
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-6 mt-2">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/aws3.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/aws4.png') }}" alt="">
                </div>
                <div class="col-md-6" style="padding: 4em;">
                    <p>This is the <span>role</span> used for the AWS credentials in Jenkins.
                    </p>
                    <p>I have attached <span>custom policies</span> to the role, allowing the provisioned EC2 instance to:
                        <br><br>- <span>Get an STS authorization token for pushing the Docker image to ECR</span>
                        <br><br>- <span>Giving the slave node server access to EC2 functionality</span>
                        <br><br>- <span>Allowing the slave node server to update the ECS service with the latest image</span>
                    </p>
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-6 mt-2">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/aws5.png') }}" alt="">
                </div>
                <div class="col-md-6" style="padding: 4em;">
                    <p>In addition to the access keys and attached policies, the slave node will need to <span>SSH into the instance</span> to update and configure the OS and dependencies. This
                        will allow Jenkins to run the <span>init script</span> and pass the AWS credentials to the Jenkinsfile pipeline script.
                    </p>
                </div>
            </div>
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
        </div>
    </div>

<!-- ecr -->
    <div class="row justify-content-center mt-4 my-4" id="ecr">
        <div class="col-md-8" id="decorator">
            <!-- intro section -->
            <div class="row">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Creating AWS ECR Permissions</h4>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-md-10" style="padding: 4em;">
                    <p>In order to allow the newly provisioned node to <span>push the new image to ECR</span>, permissions must be <span>attached to the instance profile role</span>.</p>
                </div>
            </div>
            <div class="row justify-content-center mt-3" style="padding-bottom: 2em;">
                <div class="col-md-6 m-auto" style="padding: 4em;">
                    <p>This will define the role's permission set for <span>performing actions on the ECR repository</span>.</p>
            </div>
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/ecr1.png') }}" alt="">
                </div>
                
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-6 my-3">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/ecr2.png') }}" alt="">
                </div>
                <div class="col-md-6 m-auto">
                    <p>For demo purposes, I gave the instance profile role <span>full rights to the ECR service for testing</span>, but I can go back and redefine the permissions set to grant only the needed permissions 
                        for the tasks required in the pipeline. </p>
                </div>
            </div>
            
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
        </div>
    </div>

<!-- dynamic cloud node -->
    <div class="row justify-content-center mt-4 my-4" id="dynamic">
        <div class="col-md-8" id="decorator">
            <!-- intro section -->
            <div class="row">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Configuring The Cloud Node for Dynamic Provisioning</h4>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-md-10" style="padding-bottom: 2vh;">
                    <p>Now that I have all of the necessary credentials configured and the permissions and policies defined, I can configure a <span>template for dynamically provisioning new slave 
                        build nodes</span>. The benefit of having servers spin up only when I need them is that these build nodes will <span>only exist when the pipeline runs</span>. After the idle timeout, 
                        the server will be automatically decommissioned until I need to run the pipeline again. Configuring this automation upfront really shows the power of cloud computing from a cost-savings 
                        perspective. Now, I will only ever need to have one minimal master node running for my Jenkins server when no jobs are running. 
                    </p>
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-5 m-auto">
                    <p>First, I will use the <span>AWS access keys</span> with the attached IAM instance profile role and <span>SSH key pair</span> to authorize Jenkins to connect to AWS 
                        and then SSH into the newly created EC2 instance.</p>
            </div>
                <div class="col-md-7">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud1.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud2.png') }}" alt="">
                </div>
                
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-7 my-3">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud3.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud4.png') }}" alt="">
                </div>
                <div class="col-md-5 m-auto">
                    <p>I then need to define an <span>AMI ID</span> to indicate what type of instance I would like for Jenkins to spin up on my behalf. I also need to indicate which region my <span>availability zones</span>
                     my instance can be created in as well as an <span>instance type</span> and size. I have already configured a <span>security group with the necessary ports exposed</span> (22, 8080, 80, 443) 
                    to allow for necessary inbound and outbound traffic to flow through my instance. I then tell Jenkins to attach that security group to each new node.</p>
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-5 m-auto">
                    <p>I can now indicate which root folder for Jenkins to use to set up a <span>temporary workspace</span> that will act as the base of operations where my repository will be cloned and the 
                    Docker image can be built from. I am using a <span>Unix</span> type AMI, and will be allowing an <span>SSH connection on port 22</span>.
                    <br><br>
                    I can then define how this node should be used. Since I only want Jenkins to spin up these nodes when needed, I set the built-in node to operate at 0, and have indicated this node 
                    configuration to be used as much as possible. This means that <span>only dynamically provisioned nodes will be used for any type of job</span>.
                </p>
            </div>
                <div class="col-md-7">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud5.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud6.png') }}" alt="">
                </div>
                
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-7 my-3">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud7.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud8.png') }}" alt="">
                </div>
                <div class="col-md-5 m-auto">
                    <p>Any additional setup not indicated by the plugin settings needs to be configured with the use of an <span>init script</span>, which will contain important directions for the new instance.
                    <br><br>
                    The init script will:
                    <br><br>
                    -<span> Update the OS</span>
                    <br><br> 
                    -<span> Install Git to clone my GitHub repository</span>
                    <br><br>
                    -<span> Install Docker and add the remote user to the Docker group</span> 
                    <br><br>
                    -<span> Create, change permissions for, and add the remote user to the new Jenkins root folder</span>
                    <br><br>
                    -<span> Change permission of the Docker service to allow the remote user to run Docker without the sudo command</span>
                    <br><br> I can then define tags to be able to identify my instance from the console if necessary.
                </p>
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-5 m-auto">
                    <p>Finally, I just need to configure a few small connection settings and I can now <span>spin up a dynamically provisioned node only when I need it</span>.</p>
            </div>
                <div class="col-md-7">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/cloud9.png') }}" alt="">
                </div>
                
            </div>
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
        </div>
    </div>
<!-- jenkinsfile dockerfile -->
<div class="row justify-content-center mt-4 my-4" id="jdfile">
    <div class="col-md-8" id="decorator">
        <!-- intro section -->
        <div class="row">
            <div class="col-11">
                <h4 class="mt-4" id="section-heading">Jenkinsfile and Dockerfile</h4>
            </div>
        </div>
        
        <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
            <div class="col-md-5 m-auto">
                <p>For this application, I am using a <span>Jenkinsfile</span> to write my pipeline build script. 
                    <br><br>
                    In the script, the first stage will <span>build and publish the Docker image to ECR</span>. This is where the <span>access keys, attached STS identity policy and ECS policy</span> come into play.
                    This will allow the script to get a temporary login password to push the new image to ECR.
                    <br><br>
                    Next, the script will <span>list the images on the repository</span>. This will confirm that the push to ECR was successful.
                    <br><br>
                    Once the new image has been pushed to the repository, the script will now <span>update the ECS cluster to run the new task on the ECS service</span>. The number of tasks can be changed based on the 
                    use case, but for demo purposes I have set my task value to 1.
                    <br><br>
                    Finally, the script will <span>wipe all Docker images or running containers from the server</span>, allowing for a clean build if I need to run builds in close proximity.</p>
        </div>
            <div class="col-md-7">
                <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/jd1.png') }}" alt="">
            </div>
            
        </div>
        <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
            <div class="col-md-6 my-3">
                <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/jd2.png') }}" alt="">
            </div>
            <div class="col-md-6 m-auto">
                <p>For my <span>Dockerfile</span>, I simply need to <span>pull a base python Docker image</span>, set my working directory, and then <span>copy and install my dependencies</span> as 
                defined in my requirements file.
                <br><br>
                I now can <span>run the Flask application</span> on a <span>Gunicorn</span> server on port 80 to allow inbound HTTP traffic. As long as I configure the ECS service to expose port 80 
                from within Docker, I will be able to access the task from a browser to view my application.</p>
            </div>
        </div>
        <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
    </div>
</div>

<!-- pipeline config -->
    <div class="row justify-content-center mt-4 my-4" id="pipeconfig">
        <div class="col-md-8" id="decorator">
            <!-- intro section -->
            <div class="row">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Creating a Pipeline Build Configuration</h4>
                </div>
            <div class="row justify-content-center mt-5" style="padding: 2em;">
                <div class="col-md-6 m-auto">
                    <p>With all of the scripts and code written and all of the authentication and configuration finished, I can now set up a <span>new pipeline job</span> to actually run the pipeline.
                        I will be choosing a <span>single branch pipeline</span> for the purposes of this project as I will not need to be managing multiple build branches for such a simple application.</p>
                </div>
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/pipe1.png') }}" alt="">
                </div>
                
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-10 m-auto">
                    <p>The goal is to <span>trigger the pipeline</span> when I commit new code to my remote repository. I can now use the <span>GitHub Webhook</span> and <span>Personal Access Token</span>
                    that I set up earlier to ensure this happens with every push I make to the repository. Once the pipeline is triggered from the Webhook, Jenkins will <span>push the new code
                    to each newly provisioned slave instance node</span>. This will then allow Docker to build the image based on each new checkout from the repository.</p>
                </div>              
            </div>
            <div class="row justify-content-center mt-5" style="padding: 2em;">
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/pipe2.png') }}" alt="">
                </div>
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/pipe3.png') }}" alt="">
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding: 2em;">
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/pipe4.png') }}" alt="">
                </div>
                <div class="col-md-6 m-auto">
                    <p>Jenkins will pull code from the <span>main branch</span>. I also need to specify the scripting that Jenkins will use. Here, I tell Jenkins to use the <span>Jenkinsfile</span> located at the base of my 
                    workspace directory. With all of the pieces in place, I will now able to run my pipeline which will use all of the automation to dynamically spin up a server to build my project.</p>
                </div>
            </div>
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
        </div>
    </div>

<!-- run -->
    <div class="row justify-content-center mt-4 my-4" id="run">
        <div class="col-md-8" id="decorator">
            <!-- intro section -->
            <div class="row">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Final Steps and Running the Pipeline</h4>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-md-10" style="padding: 4em;">
                    <p>I can now run my pipeline automation. My pipeline will be triggered from my <span>GitHubSCM Webhook</span>. Jenkins will <span>spin up a slave build node</span>, 
                        <span>build my Docker image</span>, <span>push the image to ECR</span>, <span>display the images on my repository</span>, and finally
                        <span>update my ECS service with the latest image from the repository.</span> 
                        <br><br>
                        This can all be done by simply committing new code to my remote repository. 
                        <br><br>
                        Jenkins will automate the entire process as soon as it receives the trigger.                        
                    </p>
                </div>
            </div>

            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-10 my-3">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin1.png') }}" alt="">
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-6 m-auto" style="padding: 4em;">
                    <p>Additionally, I can <span>spin up a pre-configured slave node manually</span> if I want to have the server running ahead of time. This is optional as the build server will be provisioned 
                        either way if I do not manually start the server.
                    </p>
                </div>
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin2.png') }}" alt="">
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin3.png') }}" alt="" style="padding-bottom: 2em;">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin4.png') }}" alt="">
                </div>
                <div class="col-md-6 m-auto" style="padding: 4em;">
                    <p>Once the SCM Webhook is triggered, Jenkins will check for available build nodes. Since the <span>previous node has been decommissioned</span>, Jenkins will now <span>tell AWS to spin up a fresh 
                        Jenkins server that is completely configured with credentials and instructions</span> to be able to build and push my application.
                    </p>
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                
                <div class="col-md-6 m-auto">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin5.png') }}" alt="">
                </div>
                <div class="col-md-6 m-auto">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin6.png') }}" alt="">
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-10 m-auto" style="padding: 4em;">
                    <p>Above, we can see a bit of what is happening in the background. Jenkins is attempting to <span>SSH into the newly created server</span> and <span>run the init script</span>. The Jenkins node will be configured 
                        with its own Jenkins dependencies, and will then <span>install the dependencies defined in the init script</span>. Once the script is finished running, Jenkins will check to make sure the proper 
                        number of defined build nodes are online and then <span>proceed to run the pipeline</span>.
                    </p>
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                
                
                <div class="col-md-6 m-auto" style="padding: 4em;">
                    <p>Jenkins will now proceed to run the pipeline after it has a <span>configured slave node up and running</span>.</p>
                </div>
                <div class="col-md-6">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin7.png') }}" alt="">
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                
                <div class="col-md-6 m-auto">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin8.png') }}" alt="">
                </div>
                <div class="col-md-6 m-auto">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin9.png') }}" alt="">
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                
                <div class="col-md-8">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin10.png') }}" alt="">
                </div>
                <div class="col-md-4 m-auto" style="padding: 4em;">
                    <p>The <span>ECS service has been successfully updated</span> and I can now connect to the newly created task in the service.</p>
                </div>
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-4 m-auto" style="padding: 4em;">
                    <p>To test that the <span>ports were properly configured</span>, I just need to visit the test html from the browser through the <span>task public DNS</span> after the pipeline completes and the new service updates.</p>
                </div>
                <div class="col-md-8">
                    <img class="rounded mx-auto d-block img-fluid" src="{{ url_for('static', filename='project-jenkins-imgs/fin11.png') }}" alt="">
                </div>
                
            </div>
            <div class="row justify-content-center mt-5" style="padding-bottom: 2em;">
                <div class="col-md-8 m-auto" style="padding: 4em;">
                    <p>Now that the <span>pipeline has run and my new task is running on ECS</span>, I can <span>safely terminate the slave node or wait for the idle timeout to have the instance self-terminate</span>. 
                        The idle timeout is 30 minutes so the same process will be repeated each time new code is committed outside of the idle window. Otherwise, Jenkins will use an existing 
                        node if it is still in service.
                    </p>
                </div>
                
            </div>
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
        </div>
    </div>
<!-- summary -->
    <div class="row justify-content-center mt-4 my-4" id="summary">
        <div class="col-md-8" id="decorator" style="padding-bottom: 3vh;">

            <div class="row justify-content-center">
                <div class="col-11">
                    <h4 class="mt-4" id="section-heading">Summary</h4>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-11">
                    <p>This project has made Jenkins my new favorite tool by far. It encompasses all the things that I love about cloud computing and DevOps. Integration, automation, containerization, 
                        dynamic provisioning of resources, and a ‘pay-as-you-go’ philosophy that makes cloud so innovative and interesting. I had a great time learning the ins and
                         outs of Jenkins and the possibilities it presents with automating any task you can think of when paired with AWS.
                    <br><br>
                    My favorite aspect of this project was the automation for sure. When you do all the work up front and just watch it work, it really is that feeling of 
                    efficiency and preparation that makes CI/CD so interesting and fulfilling to me. I will be implementing Jenkins in more of my projects in the future and 
                    I have learned many useful tools while creating this project.
                    <br><br>
                    Integrating AWS and Jenkins really shows the power of cloud integration and automation and really inspires me to explore more of the possibilities that are 
                    present when combining powerful tools like this. I learned a lot doing this project and was very happy with the result. I look forward to hearing your reactions 
                    to the project and I sincerely hope you enjoyed this dive into the world of Jenkins. 
                    <br><br>
                    <p style="font-style: italic; opacity: 50%;">Steve</p>
                    </p> 
                </div>
            </div>
            <div class="my-4"><h6 class="text-center"> <a class="btt" href="#cont">Back to Top</a></h6></div>
        </div>
    </div>


</div>
















{% endblock %}